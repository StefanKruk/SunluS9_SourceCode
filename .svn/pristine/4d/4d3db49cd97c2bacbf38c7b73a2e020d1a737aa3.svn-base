/**
 * Marlin 3D Printer Firmware
 * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
 *
 * Based on Sprinter and grbl.
 * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 */

#include "../../../../inc/MarlinConfigPre.h"

#if ENABLED(DGUS_LCD_UI_SUNLU)

#include "../DGUSScreenHandler.h"

#include "../../../../MarlinCore.h"
#include "../../../../gcode/queue.h"
#include "../../../../libs/duration_t.h"
#include "../../../../module/settings.h"
#include "../../../../module/temperature.h"
#include "../../../../module/motion.h"
#include "../../../../module/planner.h"
#include "../../../../module/printcounter.h"
#include "../../../../sd/cardreader.h"

#if ENABLED(POWER_LOSS_RECOVERY)
  #include "../../../../feature/powerloss.h"
#endif

#define Cancel_FilamentRunout
#if ENABLED(SDSUPPORT)

  static ExtUI::FileList filelist;

  void DGUSScreenHandler::DGUSLCD_SD_FileSelected(DGUS_VP_Variable &var, void *val_ptr) {
    uint16_t touched_nr = (int16_t)swap16(*(uint16_t*)val_ptr) -1;//+ top_file
//	do{ MYSERIAL1.print("touched_nr:"); MYSERIAL1.println(touched_nr); }while(0);
//	do{ MYSERIAL1.print("file_index_offset[touched_nr]:"); MYSERIAL1.println(file_index_offset[touched_nr]); }while(0);
	
    if (file_index_offset[touched_nr] > filelist.count()) return;
	//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
    if (!filelist.seek(file_index_offset[touched_nr])) return;
	//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
	//do{ MYSERIAL1.print("touched_nr:"); MYSERIAL1.println(touched_nr); }while(0);
	//do{ MYSERIAL1.print("top_file:"); MYSERIAL1.println(top_file); }while(0);

    if (filelist.isDir()) {
      filelist.changeDir(filelist.filename());
      top_file = 0;
      ForceCompleteUpdate();
      return;
    }
	//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);

    #if ENABLED(DGUS_PRINT_FILENAME)
      // Send print filename
      DGUS_VP_Variable tvar;
	  char tmpfilename[VP_SD_FileName_LEN + 1] = "";
	  tvar.size=32;
	  tvar.VP=RTX_filename;
	  tvar.memadr=(void*)tmpfilename;
	  memset(tmpfilename,'\0',sizeof(tmpfilename));
	  snprintf_P(tmpfilename, VP_SD_FileName_LEN, PSTR("%s%c"), filelist.filename(), filelist.isDir() ? '/' : 0);
      DGUSLCD_SendStringToDisplay(tvar);
    #endif
	temp_runout_enable=ExtUI::getFilamentRunout_enabled();
    // Setup Confirmation screen
    file_to_print = file_index_offset[touched_nr];
	//planner.leveling_active=true;
    HandleUserConfirmationPopUp(VP_SD_FileSelectConfirm, nullptr, PSTR("Print file"), filelist.filename(), PSTR("from SD Card?"), true, true, false, true);
	No_Refresh=false;//david //The file list will be refreshed next time;
    //HandleUserConfirmationPopUp(VP_SD_FileSelectConfirm, nullptr, PSTR("Print file"), filelist.filename(), PSTR("from SD Card?"), true, true, false, true);
  }

  void DGUSScreenHandler::DGUSLCD_SD_StartPrint(DGUS_VP_Variable &var, void *val_ptr) {
  	
    uint16_t result = (int16_t)swap16(*(uint16_t*)val_ptr);
    if (!filelist.seek(file_to_print) || result==2)
    {
    	PopToOldScreen();
		return;
    }
	ExtUI::setFilamentRunout_enabled(temp_runout_enable);
	
	ExtUI::injectCommands_P(PSTR("M500"));
    ExtUI::printFile(filelist.shortFilename());
	//			do{ MYSERIAL1.print("DGUSLCD_SD_StartPrint:"); MYSERIAL1.println(__LINE__); }while(0);
  //  GotoScreen(DGUSLCD_SCREEN_STATUS);
  	if(ui.language==UI_LANGUAGE_CHINESE)
    	GotoScreen(DGUSLCD_SCREEN_CN_STATUS);
  	else
    	GotoScreen(DGUSLCD_SCREEN_EN_STATUS);
	//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
	No_Refresh=false;//david //The file list will be refreshed next time;
  }
#if 0
  void DGUSScreenHandler::DGUSLCD_DEAL_EVENT(DGUS_VP_Variable &var) {
  		switch(VP_Value)
  		{
  			case 1:
			{
				char str[11]={0};
				sprintf(str,"G92 E%f",back_e);
				//if(filament_data.action ==1) 	sprintf(str,"M701 L%d",int(filament_data.purge_length));
				//else 						 	sprintf(str,"M702 U%d",int(filament_data.purge_length));
				do{ MYSERIAL1.print("str:"); MYSERIAL1.println(__LINE__); }while(0);
					if(ExtUI::isMoving())	return;
				do{ MYSERIAL1.print("str:"); MYSERIAL1.println(__LINE__); }while(0);
			        if (ExtUI::isprintingIsPaused()) {
			          ExtUI::resumePrint();
					  if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_EN_STATUS);
					  else		  								  GotoScreen(DGUSLCD_SCREEN_CN_STATUS);
			        }		
  			}
			break;
  		}
  }
#endif


void DGUSScreenHandler::Filament_Runout_AutoRecovery() 
{
	static uint8_t Filament_Runout_Cnt=0;
#ifdef	Cancel_FilamentRunout
		
			temp_current_position_z = current_position.z;
			gcode.process_subcommands_now_P(PSTR("G28 X0 Y0"));
			planner.synchronize();
			current_position.z=temp_current_position_z;
			do_blocking_move_to_z(current_position.z);
			planner.synchronize();

//			do{ MYSERIAL1.print("Filament_Runout_AutoRecovery:");  }while(0);
//			if(ExtUI::getFilamentRunout_enabled()&0x03){
//				ExtUI::ResetFilamentRunout();
//				ExtUI::setTestFilamentRunoutState(true);
//				ExtUI::setTestFilamentRunoutState(false);
//			}

		if(ScreenHandler.click_start_print_State ==0)
		{



	  		float temp_AxisPosition_mm=ExtUI::getAxisPosition_mm(filament_data.extruder);
	  		if(ExtUI::getFilamentRunout_enabled()&0x03){
				Filament_Runout_Cnt++;
				if(Filament_Runout_Cnt>=2)  //enter two times
				{
					Filament_Runout_Cnt =0;
					ScreenHandler.Filament_Runout_Check_Flag =true;
				}
				do{ MYSERIAL1.println("Filament_Runout_AutoRecovery:"); }while(0);
				
				ExtUI::ResetFilamentRunout();
				ExtUI::setTestFilamentRunoutState(true);
	      		ExtUI::setAxisPosition_mm(temp_AxisPosition_mm+6, filament_data.extruder);
				planner.synchronize();
	      		ExtUI::setAxisPosition_mm(temp_AxisPosition_mm+12, filament_data.extruder);
				planner.synchronize();
	      		ExtUI::setAxisPosition_mm(temp_AxisPosition_mm+18, filament_data.extruder);
				planner.synchronize();
//	      		ExtUI::setAxisPosition_mm(temp_AxisPosition_mm+18, filament_data.extruder);
//				planner.synchronize();				

				
				ExtUI::setTestFilamentRunoutState(false);	

#if 1
				if((ExtUI::getFilamentRunoutState())==0){				
		      		ExtUI::setAxisPosition_mm(temp_AxisPosition_mm+12, filament_data.extruder);
					planner.synchronize();				
				}
#endif
				
	  		}

		#if 1	
//	  		if(back_e!=0)		temp_AxisPosition_mm=back_e;
//			else				temp_AxisPosition_mm=ExtUI::getAxisPosition_mm(filament_data.extruder)-18;

			current_position.e=temp_AxisPosition_mm;
			planner.set_e_position_mm(current_position.e);
			planner.synchronize();

			do{ MYSERIAL1.print("AutoRecovery_temp_AxisPosition_mm="); MYSERIAL1.println(temp_AxisPosition_mm); }while(0);
			do{ MYSERIAL1.print("AutoRecovery_getAxisPosition_mm="); MYSERIAL1.println(getAxisPosition_mm(filament_data.extruder)); }while(0);

			
		#endif	
		}

		ScreenHandler.click_start_print_State =0;
		
//		do{ MYSERIAL1.print("getFilamentRunout_enabled:");  }while(0);
//		do{ MYSERIAL1.print((ExtUI::getFilamentRunout_enabled()&0x03));  }while(0);
		if((ExtUI::getFilamentRunoutState())==0){
			if (ExtUI::get_has_run_out()==0) {
				ScreenHandler.resume_start_print_State =0;
				
			  ExtUI::resumePrint();
			}
		}
				
			

#endif


}

  

  void DGUSScreenHandler::DGUSLCD_SD_ResumePauseAbort(DGUS_VP_Variable &var, void *val_ptr) {
    uint16_t touched_nr = (int16_t)swap16(*(uint16_t*)val_ptr);
//	do{ MYSERIAL1.print("touched_nr:"); MYSERIAL1.println(touched_nr); }while(0);

	//ExtUI::setTestFilamentRunoutState(true);
	//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
    //if (!ExtUI::isPrintingFromMedia()) return; // avoid race condition when user stays in this menu and printer finishes.
    switch (swap16(*(uint16_t*)val_ptr)) {
	case 0://  pause print
		if(ui.language==UI_LANGUAGE_ENGLISH)		GotoScreen(DGUSLCD_SCREEN_EN_PAUSE_SELECT);
		else										GotoScreen(DGUSLCD_SCREEN_CN_PAUSE_SELECT);
	break;
		
	  case 3: { // Resume
			ScreenHandler.resume_start_print_State =1;
			ScreenHandler.click_start_print_State =1;
			
//		  do{ MYSERIAL1.print("DGUSLCD_SD_ResumePauseAbort resume:");  }while(0);
			power_loss_resume=0;
			if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_EN_LEVELING);
			else										  GotoScreen(DGUSLCD_SCREEN_CN_LEVELING);//homeing
			temp_current_position_z = current_position.z;
			gcode.process_subcommands_now_P(PSTR("G28 X0 Y0"));
			planner.synchronize();
			current_position.z=temp_current_position_z;
			do_blocking_move_to_z(current_position.z);
			planner.synchronize();



			float temp_AxisPosition_mm =0;

			if(ExtUI::getFilamentRunoutState()){
				if(ExtUI::getFilamentRunout_enabled()&0x03){
					ExtUI::ResetFilamentRunout();
				}

				if(back_e!=0)		temp_AxisPosition_mm=back_e;
				else				temp_AxisPosition_mm=ExtUI::getAxisPosition_mm(filament_data.extruder);
				current_position.e=temp_AxisPosition_mm;
				planner.set_e_position_mm(current_position.e);
				planner.synchronize();
				do{ MYSERIAL1.print("resume_temp_AxisPosition_mm="); MYSERIAL1.println(temp_AxisPosition_mm); }while(0);
				do{ MYSERIAL1.print("resume_getAxisPosition_mm="); MYSERIAL1.println(getAxisPosition_mm(filament_data.extruder)); }while(0);

				
			}
			if (ExtUI::isprintingIsPaused()||ExtUI::get_has_run_out()==0) {
			  ExtUI::resumePrint();
			  
			ScreenHandler.resume_start_print_State =0;
			}else
			{
				PopToOldScreen();
			}
	  }
		break;


      case 1: // Pause     
        if (!ExtUI::isPrintingFromMediaPaused()) {
//				do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
			if(ui.language==UI_LANGUAGE_ENGLISH)		  ScreenHandler.GotoScreen(DGUSLCD_SCREEN_EN_LEVELING);
			else		  								  ScreenHandler.GotoScreen(DGUSLCD_SCREEN_CN_LEVELING);//homeing
			
          ExtUI::pausePrint();
        }
        break;
      case 2: // Abort
     // do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
      		ExtUI::stopPrint();
//		  GCodeQueue::is_online_print=false;
		  if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_EN_LEVELING);
		  else		  								  GotoScreen(DGUSLCD_SCREEN_CN_LEVELING);//homeing
			
      	  planner.synchronize();
		  if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_EN_MAIN);
		  else		  								  GotoScreen(DGUSLCD_SCREEN_CN_MAIN);
     //   HandleUserConfirmationPopUp(VP_SD_AbortPrintConfirmed, nullptr, PSTR("Abort printing"), filelist.filename(), PSTR("?"), true, true, false, true);
        break;
	  case 4:
	//	do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
//		do{ MYSERIAL1.println("GotoScreen_DGUSLCD_SCREEN_CN_CHANGE_FILAMENT111");  }while(0);
		if(ScreenHandler.Filament_Runout_screen_state){
			
//		do{ MYSERIAL1.println("GotoScreen_DGUSLCD_SCREEN_CN_CHANGE_FILAMENT222");  }while(0);
			ScreenHandler.Filament_Runout_screen_state =0;
			GotoScreen(DGUSLCD_SCREEN_CN_CHANGE_FILAMENT);
		}
		else
	  	PopToOldScreen();
	  break;
	  case 5://cancel jump
		  if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_EN_CANCEL_SELECT);
		  else		  								  GotoScreen(DGUSLCD_SCREEN_CN_CANCEL_SELECT);
	  break;
	  case 7://start print
//		  do{ MYSERIAL1.println("DGUSLCD_SD_ResumePauseAbort_77777");  }while(0);
	  	  ScreenHandler.Filament_Runout_screen_state  =1;
		  if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_EN_PRINTINGCONTINUE);
		  else										  GotoScreen(DGUSLCD_SCREEN_CN_PRINTINGCONTINUE);
	  break;
     	default:
     	break;
    }
  }



    void DGUSScreenHandler::DGUSLCD_SD_FilamentResumePauseAbort(DGUS_VP_Variable &var, void *val_ptr) {
    uint16_t touched_nr = (int16_t)swap16(*(uint16_t*)val_ptr);
//	do{ MYSERIAL1.print("touched_nr:"); MYSERIAL1.println(touched_nr); }while(0);

	//ExtUI::setTestFilamentRunoutState(true);
	//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
    //if (!ExtUI::isPrintingFromMedia()) return; // avoid race condition when user stays in this menu and printer finishes.
    switch (swap16(*(uint16_t*)val_ptr)) {
	case 0://  pause print
		if(ui.language==UI_LANGUAGE_ENGLISH)		GotoScreen(DGUSLCD_SCREEN_EN_PAUSE_SELECT);
		else										GotoScreen(DGUSLCD_SCREEN_CN_PAUSE_SELECT);
	break;
		
      case 3: { // Resume
      		ScreenHandler.resume_start_print_State =1;
      		ScreenHandler.click_start_print_State =1;
			
//		  do{ MYSERIAL1.print("DGUSLCD_SD_ResumePauseAbort resume:");  }while(0);
		    power_loss_resume=0;
			if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_EN_LEVELING);
			else		  								  GotoScreen(DGUSLCD_SCREEN_CN_LEVELING);//homeing
			temp_current_position_z = current_position.z;
			gcode.process_subcommands_now_P(PSTR("G28 X0 Y0"));
			planner.synchronize();
			current_position.z=temp_current_position_z;
			do_blocking_move_to_z(current_position.z);
			planner.synchronize();



			float temp_AxisPosition_mm =0;

		    if(ExtUI::getFilamentRunoutState()){
	      		if(ExtUI::getFilamentRunout_enabled()&0x03){
					ExtUI::ResetFilamentRunout();
	      		}

	      		if(back_e!=0)		temp_AxisPosition_mm=back_e;
				else				temp_AxisPosition_mm=ExtUI::getAxisPosition_mm(filament_data.extruder);
				current_position.e=temp_AxisPosition_mm;
				planner.set_e_position_mm(current_position.e);
				planner.synchronize();
				do{ MYSERIAL1.print("resume_temp_AxisPosition_mm="); MYSERIAL1.println(temp_AxisPosition_mm); }while(0);
				do{ MYSERIAL1.print("resume_getAxisPosition_mm="); MYSERIAL1.println(getAxisPosition_mm(filament_data.extruder)); }while(0);

				
		    }
	        if (ExtUI::isprintingIsPaused()||ExtUI::get_has_run_out()==0) {
	          ExtUI::resumePrint();
			  
			ScreenHandler.resume_start_print_State =0;
	        }else
	        {
	        	PopToOldScreen();
	        }
      } break;
      case 1: // Pause
        if (!ExtUI::isPrintingFromMediaPaused()) {
//				do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
			if(ui.language==UI_LANGUAGE_ENGLISH)		  ScreenHandler.GotoScreen(DGUSLCD_SCREEN_EN_LEVELING);
			else		  								  ScreenHandler.GotoScreen(DGUSLCD_SCREEN_CN_LEVELING);//homeing
          ExtUI::pausePrint();
        }
        break;
      case 2: // Abort
     // do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
      		ExtUI::stopPrint();
//		  GCodeQueue::is_online_print=false;
		  if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_EN_LEVELING);
		  else		  								  GotoScreen(DGUSLCD_SCREEN_CN_LEVELING);//homeing
			
      	  planner.synchronize();
		  if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_EN_MAIN);
		  else		  								  GotoScreen(DGUSLCD_SCREEN_CN_MAIN);
     //   HandleUserConfirmationPopUp(VP_SD_AbortPrintConfirmed, nullptr, PSTR("Abort printing"), filelist.filename(), PSTR("?"), true, true, false, true);
        break;
	  case 4:
		  if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_CN_CHANGE_FILAMENT);
		  else		  								  GotoScreen(DGUSLCD_SCREEN_CN_CHANGE_FILAMENT);

	  break;
	  case 5://cancel jump
		  if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_CN_FILAMENT_CANCEL);
		  else		  								  GotoScreen(DGUSLCD_SCREEN_CN_FILAMENT_CANCEL);
	  break;
	  case 7://start print
//		  do{ MYSERIAL1.println("DGUSLCD_SD_ResumePauseAbort_77777");  }while(0);
//	  	  ScreenHandler.Filament_Runout_screen_state  =1;
//		  if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_EN_PRINTINGCONTINUE);
//		  else										  GotoScreen(DGUSLCD_SCREEN_CN_PRINTINGCONTINUE);
	  break;
     	default:
     	break;
    }
  }
  void DGUSScreenHandler::DGUSLCD_SD_SendFilename(DGUS_VP_Variable& var) {

	static uint8_t findex=0;
	if(No_Refresh)	return;
	
	if(var.VP==VP_RTX_sdfile_col_4)	{
		No_Refresh=true;
			//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
	}
    uint16_t target_line = (var.VP - VP_RTX_sdfile_col_1) / VP_SD_FileName_LEN;////VP_SD_FileName0
//    if (target_line > DGUS_SD_FILESPERSCREEN) return;
    char tmpfilename[VP_SD_FileName_LEN + 1] = "";
    char tmpfilename_NULL[VP_SD_FileName_LEN + 1] = "";
    var.memadr = (void*)tmpfilename;

	char gcode_m[7]=".gcode";
	gcode_m[6]="";
	bool find_gcode_file=false;
//			do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
//			do{ MYSERIAL1.print("findex:"); MYSERIAL1.println(findex); }while(0);
//			do{ MYSERIAL1.print("filelist.count:"); MYSERIAL1.println(filelist.count()); }while(0);
//			do{ MYSERIAL1.print("top_file:"); MYSERIAL1.println(top_file); }while(0);
//			do{ MYSERIAL1.print("target_line:"); MYSERIAL1.println(target_line); }while(0);
	while(filelist.count()>0&&filelist.count()>gcode_file_offset){
		memset(tmpfilename,'\0',sizeof(tmpfilename));
		if (filelist.seek(top_file + target_line+gcode_file_offset)) {
		      snprintf_P(tmpfilename, VP_SD_FileName_LEN, PSTR("%s%c"), filelist.filename(), filelist.isDir() ? '/' : 0); // snprintf_P(tmpfilename, VP_SD_FileName_LEN, PSTR("%s"), filelist.filename());
		}
		else {
			memset(tmpfilename,' ',sizeof(tmpfilename));
	    	var.memadr = (void*)tmpfilename;
	    	DGUSLCD_SendStringToDisplay(var);
			return;
		}
		uint8_t i=sizeof(gcode_m)-1;
		if(strlen(tmpfilename)<6)
		{
//			gcode_file_offset++;
//			continue;
		}
		do{
			if(memcmp(tmpfilename+i-5,gcode_m,sizeof(gcode_m)-1)==0)
			{
				find_gcode_file=true;
				break;
			}
			i++;
		}while(tmpfilename[i]!=""&&i<32);
		if(find_gcode_file)
		{
			find_gcode_file=false;
	    	var.memadr = (void*)tmpfilename_NULL;
	    	DGUSLCD_SendStringToDisplay(var);
	    	var.memadr = (void*)tmpfilename;
	    	DGUSLCD_SendStringToDisplay(var);
			file_index_offset[findex++]=gcode_file_offset+target_line+top_file;
//			do{ MYSERIAL1.print("file_index_offset[findex]:"); MYSERIAL1.println(file_index_offset[findex-1]); }while(0);
			if(findex>=4)	findex=0;
			return;
		}
//		gcode_file_offset++;
	}
//	do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
			
//	do{ MYSERIAL1.print("gcode_file_offset="); MYSERIAL1.println(gcode_file_offset); }while(0);
  }

  void DGUSScreenHandler::SDCardInserted() {
    top_file = 0;
	gcode_file_offset=0;
    filelist.refresh();
	has_sdcar=true;
    auto cs = getCurrentScreen();
    if (cs == DGUSLCD_SCREEN_CN_MAIN ||cs == DGUSLCD_SCREEN_EN_MAIN || cs == DGUSLCD_SCREEN_SDFILELIST_NULL|| cs == DGUSLCD_SCREEN_SDFILELIST_NULL_CN ){
		if(ui.language==UI_LANGUAGE_ENGLISH)      GotoScreen(DGUSLCD_SCREEN_EN_SDFILELIST);
		else									  GotoScreen(DGUSLCD_SCREEN_CN_SDFILELIST);
    }
  }

  void DGUSScreenHandler::SDCardRemoved() {
	has_sdcar=false;
    if (current_screen == DGUSLCD_SCREEN_EN_SDFILELIST || current_screen == DGUSLCD_SCREEN_CN_SDFILELIST)
	{
		if(ui.language==UI_LANGUAGE_ENGLISH)      GotoScreen(DGUSLCD_SCREEN_SDFILELIST_NULL);
		else									  GotoScreen(DGUSLCD_SCREEN_SDFILELIST_NULL_CN);
    }
  }
  void DGUSScreenHandler::IntoSleep()
  {
  	uint8_t System_Config[4];
	memcpy(System_Config,System_Config_0X80_D1,sizeof(System_Config));
	System_Config[0]=0x5A;
	System_Config[3] |=(1<<2);
	//do{ MYSERIAL1.print("System_Config_0X80_D1:"); MYSERIAL1.println(System_Config_0X80_D1); }while(0);
//	do{ MYSERIAL1.print("System_Config[3]:"); MYSERIAL1.println(System_Config[3]); }while(0);
	dgusdisplay.WriteVariable(VP_GetCFG, System_Config, sizeof(System_Config), true);
  }
  void DGUSScreenHandler::OutoSleep()
  {
   	uint8_t System_Config[4];
	memcpy(System_Config,System_Config_0X80_D1,sizeof(System_Config));
	System_Config[0]=0x5A;
	System_Config[3] &=(~(1<<2));
	
	//do{ MYSERIAL1.print("System_Config_0X80_D1:"); MYSERIAL1.println(System_Config_0X80_D1); }while(0);
//	do{ MYSERIAL1.print("System_Config[3]:"); MYSERIAL1.println(System_Config[3]); }while(0);
	dgusdisplay.WriteVariable(VP_GetCFG, System_Config, sizeof(System_Config), true); 	
  }
  void DGUSScreenHandler::WaitMove()
  {
	if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_EN_LEVELING);
	else		  								  GotoScreen(DGUSLCD_SCREEN_CN_LEVELING);//homeing
  	while(ExtUI::isMoving())	planner.synchronize();	 	
  }
  void DGUSScreenHandler::SDPrintingFinished() {

	WaitMove();
    if(ui.language==UI_LANGUAGE_CHINESE)    GotoScreen(DGUSLCD_SCREEN_CN_PRINTINGFINISHED);
	else									GotoScreen(DGUSLCD_SCREEN_EN_PRINTINGFINISHED);  	
    if (ui.auto_turn_off) {
      queue.exhaust();
	  queue.ring_buffer.clear();
	//  uint8_t tmp=2;
	//  dgusdisplay.ReadVariable(VP_GetCFG, &tmp, 1, true);//get System_Config data addr == 0x0080
	  /*
	  #if 1
	  uint8_t tmp=0x02;
	  
  	  dgusdisplay.ReadVariable(VP_GetCFG, &tmp, 1, true);
	  #else			
	  uint8_t System_Config[4];
	  System_Config[0]=0x5A;
	  System_Config[1]=0x14;
	  System_Config[2]=0x03;
	  System_Config[3]=0x3C;
			uint16_t System_Config16[2];
	//		memcpy(System_Config,(uint8_t*)val_ptr,sizeof(System_Config));
	//		memcpy(System_Config16,(uint16_t*)val_ptr,sizeof(System_Config16));
			do{ MYSERIAL1.print("System_Config[0]:"); MYSERIAL1.println(System_Config[0]); }while(0);
			do{ MYSERIAL1.print("System_Config[1]:"); MYSERIAL1.println(System_Config[1]); }while(0);
			do{ MYSERIAL1.print("System_Config[2]:"); MYSERIAL1.println(System_Config[2]); }while(0);
			do{ MYSERIAL1.print("System_Config[3]:"); MYSERIAL1.println(System_Config[3]); }while(0);
			//IntoSleep(System_Config);
	//		System_Config[3] |=1<<2;
  	  		dgusdisplay.WriteVariable(VP_GetCFG, System_Config, sizeof(System_Config), true);
	  #endif*/
	  IntoSleep();
      gcode.process_subcommands_now_P(PSTR("M81"));
    }
    
  }

#endif // SDSUPPORT

void DGUSScreenHandler::ScreenChangeHook(DGUS_VP_Variable &var, void *val_ptr) {
  uint8_t *tmp = (uint8_t*)val_ptr;

  // The keycode in target is coded as <from-frame><to-frame>, so 0x0100A means
  // from screen 1 (main) to 10 (temperature). DGUSLCD_SCREEN_POPUP is special,
  // meaning "return to previous screen"
  DGUSLCD_Screens target = (DGUSLCD_Screens)tmp[1];

  DEBUG_ECHOLNPAIR("\n DEBUG target", target);

  if (target == DGUSLCD_SCREEN_POPUP) {
    // Special handling for popup is to return to previous menu
    if (current_screen == DGUSLCD_SCREEN_POPUP && confirm_action_cb) confirm_action_cb();
    PopToOldScreen();
    return;
  }

  UpdateNewScreen(target);

  #ifdef DEBUG_DGUSLCD
    if (!DGUSLCD_FindScreenVPMapList(target)) DEBUG_ECHOLNPAIR("WARNING: No screen Mapping found for ", target);
  #endif
}
/*
constexpr uint16_t VP_RK_home_all=0x2240;
constexpr uint16_t VP_RK_move_x_r=0x2250;
constexpr uint16_t VP_RK_move_x_p=0x2260;
constexpr uint16_t VP_RK_move_z_p=0x2270;
constexpr uint16_t VP_RK_move_z_r=0x2280;
constexpr uint16_t VP_RK_move_y_p=0x2290;
constexpr uint16_t VP_RK_move_y_r=0x22A0;
constexpr uint16_t VP_RK_home_x=0x22B0;
constexpr uint16_t VP_RK_home_y=0x22C0;
constexpr uint16_t VP_RK_home_z=0x22D0;
*/
void DGUSScreenHandler:: HandleManualMove(DGUS_VP_Variable &var, void *val_ptr) {
  DEBUG_ECHOLNPGM("HandleManualMove");

  int16_t movevalue = 0;//swap16(*(uint16_t*)val_ptr);
 /* #if ENABLED(DGUS_UI_MOVE_DIS_OPTION)
    if (movevalue) {
      const uint16_t choice = *(uint16_t*)var.memadr;
      movevalue = movevalue < 0 ? -choice : choice;
    }
  #endif*/
  char axiscode;
  unsigned int speed = 1500; // FIXME: get default feedrate for manual moves, dont hardcode.
  uint8_t Z_ADD =0,Z_SUB =0;
  static millis_t get_cur_time=0,get_last_time=0;  
  switch (var.VP) {
    //default: return;

    //case VP_MOVE_X:
    case VP_RK_move_x_r:
  	  movevalue=0-motor_stper;
	  if(current_position.x<=0)	return;
	  if(current_position.x-(movevalue/100)<=0)
		movevalue=current_position.x*100;
	//  MYSERIAL1.print("current_position.x:");
	//  MYSERIAL1.println(current_position.x);
      axiscode = 'X';
      if (!ExtUI::canMove(ExtUI::axis_t::X)) goto cannotmove;
      break;
    case VP_RK_move_x_p:
  	  movevalue=motor_stper;
      axiscode = 'X';
      if (!ExtUI::canMove(ExtUI::axis_t::X)) goto cannotmove;
      break;

    //case VP_MOVE_Y:
    case VP_RK_move_y_r:
  	  movevalue=0-motor_stper;
	  if(current_position.y<=0)	return;
	  if(current_position.y-(movevalue/100)<=0)
		movevalue=current_position.y*100;
      axiscode = 'Y';
      if (!ExtUI::canMove(ExtUI::axis_t::Y)) goto cannotmove;
      break;
    case VP_RK_move_y_p:
      axiscode = 'Y';
  	  movevalue=motor_stper;
      if (!ExtUI::canMove(ExtUI::axis_t::Y)) goto cannotmove;
      break;

    //case VP_MOVE_Z:
    case VP_RK_move_z_r:
	  	Z_SUB =1;
      if(current_screen==DGUSLCD_SCREEN_CN_LEVELING ||
	  	current_screen==DGUSLCD_SCREEN_EN_LEVELING ||
	  	current_screen==DGUSLCD_SCREEN_EN_LEVELING_Child ||
	  	current_screen==DGUSLCD_SCREEN_CN_LEVELING_Child ||
	  	current_screen==DGUSLCD_SCREEN_EN_LEVELING_Child_OVER ||
	  	current_screen==DGUSLCD_SCREEN_CN_LEVELING_Child_OVER )
      	{
      		//relative_mode=false;
			if(planner.position.z==0)
			{
				//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
				planner.position.z+=40;
				z_compensate_adust+=40;
				ExtUI::setProbeOffset_Z_mm(-0.1);
				save_par=true;
				smile_adjustZ=true;
			}
      	}
  	  movevalue=0-motor_stper;
	  if(!smile_adjustZ)
	  {
		  if(current_position.z<=0)	return;
		  if(current_position.z-(movevalue/100)<=0)
			movevalue=current_position.z*100;
	  }
	  	
      speed = 300; // default to 5mm/s
      if (!ExtUI::canMove(ExtUI::axis_t::Z)) goto cannotmove;
      break;
    case VP_RK_move_z_p:
  	  movevalue=motor_stper;
      axiscode = 'Z';	
	  Z_ADD =1;
      speed = 300; // default to 5mm/s
      if(current_screen==DGUSLCD_SCREEN_CN_LEVELING ||
	  	current_screen==DGUSLCD_SCREEN_EN_LEVELING ||
	  	current_screen==DGUSLCD_SCREEN_EN_LEVELING_Child ||
	  	current_screen==DGUSLCD_SCREEN_CN_LEVELING_Child ||
	  	current_screen==DGUSLCD_SCREEN_EN_LEVELING_Child_OVER ||
	  	current_screen==DGUSLCD_SCREEN_CN_LEVELING_Child_OVER )
      	{
      		//relative_mode=false;
			if(z_compensate_adust<=0)
			{
				z_compensate_adust=0;
				ExtUI::setProbeOffset_mm(0,2);
			}
			else
			{
				z_compensate_adust-=40;
				ExtUI::setProbeOffset_Z_mm(+0.1);
			}
			save_par=true;
			smile_adjustZ=true;
			//planner.position.set(planner.position.x,planner.position.y,planner.position.z)
      	}
      if (!ExtUI::canMove(ExtUI::axis_t::Z)) goto cannotmove;
      break;

    //case VP_HOME_ALL: // only used for homing
    case VP_RK_home_all: // only used for homing
      axiscode  = '\0';
      movevalue = 0; // ignore value sent from display, this VP is _ONLY_ for homing.
      break;
    case VP_RK_home_x: // only used for homing
      axiscode  = 'X';
      movevalue = 0; // ignore value sent from display, this VP is _ONLY_ for homing.
      break;
    case VP_RK_home_y: // only used for homing
      axiscode  = 'Y';
      movevalue = 0; // ignore value sent from display, this VP is _ONLY_ for homing.
      break;
    case VP_RK_home_z: // only used for homing
      axiscode  = 'Z';
      movevalue = 0; // ignore value sent from display, this VP is _ONLY_ for homing.
      break;
  }

  if (!movevalue) {
    // homing
    DEBUG_ECHOPAIR(" homing ", AS_CHAR(axiscode));
    char buf[6] = "G28 X";
    buf[4] = axiscode;
    //DEBUG_ECHOPAIR(" ", buf);
    queue.enqueue_one_now(buf);
    //DEBUG_ECHOLNPGM(" âœ“");
    
    //do{ MYSERIAL1.print("past_screens:"); MYSERIAL1.println(past_screens[0]); }while(0);
	//if(ui.language==UI_LANGUAGE_CHINESE)		GotoScreen(DGUSLCD_SCREEN_CN_LEVELING);
	//else if(ui.language==UI_LANGUAGE_ENGLISH)		GotoScreen(DGUSLCD_SCREEN_EN_LEVELING);
    //do{ MYSERIAL1.print("past_screens1:"); MYSERIAL1.println(past_screens[0]); }while(0);
    motor_stper=10;//david for reset 0.1
    ForceCompleteUpdate();
    return;
  }
  else {
    // movement
	if(Z_SUB||Z_ADD)
	{
 		 get_cur_time=millis();
		 if(get_cur_time-get_last_time<800)
		 {
			 return;	
		 }
		 else 
		 {
			 get_last_time=get_cur_time;
		
		 }	
	}

	if(motor_stper == VP_RK_10_step)
	{
		if (ExtUI::isMoving()) return ;
	}
	
    DEBUG_ECHOPAIR(" move ", AS_CHAR(axiscode));
    bool old_relative_mode = relative_mode;
    if (!relative_mode ) {
      queue.enqueue_now_P(PSTR("G91"));
    }
    char buf[32]; // G1 X9999.99 F12345
    unsigned int backup_speed = MMS_TO_MMM(feedrate_mm_s);
    char sign[] = "\0";
    int16_t value = movevalue / 100;
    if (movevalue < 0) { value = -value; sign[0] = '-';}
    int16_t fraction = ABS(movevalue) % 100;
    snprintf_P(buf, 32, PSTR("G0 %c%s%d.%02d F%d"), axiscode, sign, value, fraction, speed);
    queue.enqueue_one_now(buf);
    if (backup_speed != speed) {
      snprintf_P(buf, 32, PSTR("G0 F%d"), backup_speed);
      queue.enqueue_one_now(buf);
    }
    if (!old_relative_mode) {
      queue.enqueue_now_P(PSTR("G90"));
    }
	smile_adjustZ=false;
  }

  ForceCompleteUpdate();
  DEBUG_ECHOLNPGM("manmv done.");
  return;

  cannotmove:
    DEBUG_ECHOLNPAIR(" cannot move ", AS_CHAR(axiscode));
    return;
}

#if HAS_PID_HEATING
  void DGUSScreenHandler::HandleTemperaturePIDChanged(DGUS_VP_Variable &var, void *val_ptr) {
  #ifndef DGUS_LCD_UI_SUNLU
    uint16_t rawvalue = swap16(*(uint16_t*)val_ptr);
    DEBUG_ECHOLNPAIR("V1:", rawvalue);
    float value = (float)rawvalue / 10;
    DEBUG_ECHOLNPAIR("V2:", value);
    float newvalue = 0;

    switch (var.VP) {
      default: return;
        #if HOTENDS >= 1
          case VP_E0_PID_P: newvalue = value; break;
          case VP_E0_PID_I: newvalue = scalePID_i(value); break;
          case VP_E0_PID_D: newvalue = scalePID_d(value); break;
        #endif
        #if HOTENDS >= 2
          case VP_E1_PID_P: newvalue = value; break;
          case VP_E1_PID_I: newvalue = scalePID_i(value); break;
          case VP_E1_PID_D: newvalue = scalePID_d(value); break;
        #endif
        #if HAS_HEATED_BED
          case VP_BED_PID_P: newvalue = value; break;
          case VP_BED_PID_I: newvalue = scalePID_i(value); break;
          case VP_BED_PID_D: newvalue = scalePID_d(value); break;
        #endif
    }

    DEBUG_ECHOLNPAIR_F("V3:", newvalue);
    *(float *)var.memadr = newvalue;

    skipVP = var.VP; // don't overwrite value the next update time as the display might autoincrement in parallel
    #endif
  }
#endif // HAS_PID_HEATING

#if ENABLED(BABYSTEPPING)
  void DGUSScreenHandler::HandleLiveAdjustZ(DGUS_VP_Variable &var, void *val_ptr) {

    int16_t flag  = 0;//swap16(*(uint16_t*)val_ptr),
  	switch(var.VP)
  	{
  		case VP_SD_Print_LiveAdjustZ_up:
			flag=20;
		break;
		case VP_SD_Print_LiveAdjustZ_down:
			flag=-20;
		break;
  	}
    int16_t  steps = flag;// ? -20 : 20;
    ExtUI::smartAdjustAxis_steps(steps, ExtUI::axis_t::Z, true);
    ForceCompleteUpdate();
	save_par=true;
	
  }
#endif

#if ENABLED(DGUS_FILAMENT_LOADUNLOAD)

  void DGUSScreenHandler::HandleFilamentOption(DGUS_VP_Variable &var, void *val_ptr) {
    DEBUG_ECHOLNPGM("HandleFilamentOption");
	//if (!(thermalManager.hotEnoughToExtrude(filament_data.extruder) && \
	//		thermalManager.targetHotEnoughToExtrude(filament_data.extruder)) && filament_data.action>0)		return;
	if(back_e==0)
	{
		back_e=ExtUI::getAxisPosition_mm(filament_data.extruder);
	}
    filament_data.heated = false;
	char str[11]="\0";
	int16_t en = (int16_t)swap16(*(uint16_t*)val_ptr);
	switch(var.VP)
	{
		case VP_RK_load_filament:
		{
      		filament_data.action = 1;
		}
		break;
		case VP_RK_unload_filament:
      		filament_data.action = 2;
		break;
	}
	if(en==1)	filament_data.purge_length = 100;
    else		filament_data.purge_length = Filament_Len;
    filament_data.extruder = ExtUI::extruder_t::E0;
	if (!(thermalManager.hotEnoughToExtrude(filament_data.extruder) && \
        thermalManager.targetHotEnoughToExtrude(filament_data.extruder)))
	{
	 	thermalManager.setTargetHotend(filament_temp_u, filament_data.extruder);
	}
	if(ExtUI::isMoving())	return;
	
//	do{ MYSERIAL1.print("back_e:"); MYSERIAL1.println(back_e); }while(0);
//	do{ MYSERIAL1.print("filament_data.purge_length:"); MYSERIAL1.println(filament_data.purge_length); }while(0);
	
	//ExtUI::setTestFilamentRunoutState(false);
	memset(str,'\0',sizeof(str));
	//do{ MYSERIAL1.print("e_point:"); MYSERIAL1.println(ExtUI::getAxisPosition_mm(filament_data.extruder)); }while(0);
	if(filament_data.action ==1) 	sprintf(str,"M701 L%d",int(filament_data.purge_length));
	else 						 	sprintf(str,"M702 U%d",int(filament_data.purge_length));
	//do{ MYSERIAL1.print("str:"); MYSERIAL1.println(str); }while(0);
	//queue.enqueue_one_now(str);
	//ExtUI::injectCommands(str);
if(current_screen==DGUSLCD_SCREEN_CN_CHANGE_FILAMENT )
{
	if(ui.language==UI_LANGUAGE_CHINESE)
		GotoScreen(DGUSLCD_SCREEN_CN_WAITOPERATE);
	else
		GotoScreen(DGUSLCD_SCREEN_CN_WAITOPERATE);

}
else
{
	if(ui.language==UI_LANGUAGE_CHINESE)
		GotoScreen(DGUSLCD_SCREEN_CN_WAITHEATING);
	else
		GotoScreen(DGUSLCD_SCREEN_CN_WAITHEATING);

}
	
	gcode.process_subcommands_now(str);
//	queue.enqueue_one_now(str);

//	planner.synchronize();	//wait command use

	PopToOldScreen();

//  	if(ui.language==UI_LANGUAGE_CHINESE)
//    	GotoScreen(DGUSLCD_SCREEN_CN_FILAMENT_PAGE);
//  	else
//    	GotoScreen(DGUSLCD_SCREEN_EN_FILAMENT_PAGE);
	
    //thermalManager.setTargetHotend(filament_temp_u, filament_data.extruder);
	
    //planner.synchronize();
    //if (filament_data.action <= 0) return;
	//if (thermalManager.hotEnoughToExtrude(filament_data.extruder) && \
    //    thermalManager.targetHotEnoughToExtrude(filament_data.extruder)) {
		
	//	memset(str,'\0',sizeof(str));
	//	sprintf(str,"M701 L%d",int(temp_len));
	//	do{ MYSERIAL1.print("str:"); MYSERIAL1.println(str); }while(0);
	//	queue.enqueue_one_now(str);
	//	ExtUI::setFilamentRunoutEnabled(false);
	//	filament_data.action=0;
	//}
	#if 0
    uint8_t e_temp = 0;
    uint16_t preheat_option = swap16(*(uint16_t*)val_ptr);
    if (preheat_option <= 8) {      // Load filament type
      filament_data.action = 1;
    }
    else if (preheat_option >= 10) { // Unload filament type
      preheat_option -= 10;
      filament_data.action = 2;
    }
    else {                          // Cancel filament operation
      filament_data.action = 0;
    }

    switch (preheat_option) {
      case 0: // Load PLA
        #ifdef PREHEAT_1_TEMP_HOTEND
          e_temp = PREHEAT_1_TEMP_HOTEND;
        #endif
        break;
      case 1: // Load ABS
        TERN_(PREHEAT_2_TEMP_HOTEND, e_temp = PREHEAT_2_TEMP_HOTEND);
        break;
      case 2: // Load PET
        #ifdef PREHEAT_3_TEMP_HOTEND
          e_temp = PREHEAT_3_TEMP_HOTEND;
        #endif
        break;
      case 3: // Load FLEX
        #ifdef PREHEAT_4_TEMP_HOTEND
          e_temp = PREHEAT_4_TEMP_HOTEND;
        #endif
        break;
      case 9: // Cool down
      default:
        e_temp = 0;
        break;
    }

    if (filament_data.action == 0) { // Go back to utility screen
      #if HOTENDS >= 1
        thermalManager.setTargetHotend(e_temp, ExtUI::extruder_t::E0);
      #endif
      #if HOTENDS >= 2
        thermalManager.setTargetHotend(e_temp, ExtUI::extruder_t::E1);
      #endif
      GotoScreen(DGUSLCD_SCREEN_UTILITY);
    }
    else { // Go to the preheat screen to show the heating progress
      switch (var.VP) {
        default: return;
          #if HOTENDS >= 1
            case VP_E0_FILAMENT_LOAD_UNLOAD:
              filament_data.extruder = ExtUI::extruder_t::E0;
              thermalManager.setTargetHotend(e_temp, filament_data.extruder);
              break;
          #endif
          #if HOTENDS >= 2
            case VP_E1_FILAMENT_LOAD_UNLOAD:
              filament_data.extruder = ExtUI::extruder_t::E1;
              thermalManager.setTargetHotend(e_temp, filament_data.extruder);
              break;
          #endif
      }
      GotoScreen(DGUSLCD_SCREEN_FILAMENT_HEATING);
    }
	#endif
  }
#if 0
  void DGUSScreenHandler::HandleFilamentLoadUnload(DGUS_VP_Variable &var) {
    DEBUG_ECHOLNPGM("HandleFilamentLoadUnload");
		  do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
    if (filament_data.action <= 0) return;
		  do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);

    // If we close to the target temperature, we can start load or unload the filament
    if (thermalManager.hotEnoughToExtrude(filament_data.extruder) && \
        thermalManager.targetHotEnoughToExtrude(filament_data.extruder)) {
      float movevalue = 0;//DGUS_FILAMENT_LOAD_LENGTH_PER_TIME;
      if (filament_data.action == 1) { // load filament
        if (!filament_data.heated) {
          //GotoScreen(DGUSLCD_SCREEN_FILAMENT_LOADING);
          filament_data.heated = true;
		  
		  do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
          movevalue = ExtUI::getAxisPosition_mm(filament_data.extruder) + 10;//movevalue;
        }
      }
      else { // unload filament
        if (!filament_data.heated) {
          //GotoScreen(DGUSLCD_SCREEN_FILAMENT_UNLOADING);
          filament_data.heated = true;
        }
        // Before unloading extrude to prevent jamming
        if (filament_data.purge_length >= 0) {
          movevalue = ExtUI::getAxisPosition_mm(filament_data.extruder) + movevalue;
          filament_data.purge_length -= movevalue;
        }
        else {
          movevalue = ExtUI::getAxisPosition_mm(filament_data.extruder) - movevalue;
        }
      }
      ExtUI::setAxisPosition_mm(movevalue, filament_data.extruder);
      planner.synchronize();
	  do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
    }
  }
#endif
#endif // DGUS_FILAMENT_LOADUNLOAD

void DGUSScreenHandler::DisplayResumeFileName()
{
	 DGUS_VP_Variable tvar;
	char tmpfilename[VP_SD_FileName_LEN + 1] = "";
	 tvar.size=32;
	 tvar.VP=RTX_filename;
	 tvar.memadr=(void*)tmpfilename;
	 memset(tmpfilename,'\0',sizeof(tmpfilename));
	 snprintf_P(tmpfilename, VP_SD_FileName_LEN, PSTR("%s%s"), recovery.info.last_filename, "power");
//	 snprintf_P(tmpfilename, VP_SD_FileName_LEN, PSTR("%s%c"), recovery.info.sd_filename, filelist.isDir() ? '/' : 0);
	 DGUSLCD_SendStringToDisplay(tvar);
	// do{ MYSERIAL1.print("tmpfilename:"); MYSERIAL1.println(tmpfilename); }while(0);
}

void DGUSScreenHandler::DGUSLCD_BACK_Deal(DGUS_VP_Variable &var,void *val_ptr)
{
	switch(var.VP)
	{
		case Back_RK_returnmain:
		{
			int16_t en = (int16_t)swap16(*(uint16_t*)val_ptr);
			if(ui.language == UI_LANGUAGE_ENGLISH)			GotoScreen(DGUSLCD_SCREEN_EN_MAIN);
			else											GotoScreen(DGUSLCD_SCREEN_CN_MAIN);
			if(en==1)
			{
				OutoSleep();
			}
			No_Refresh=false;//david //The file list will be refreshed next time;
		}
		break;
		case Back_RK_returnutilities:
		{
			int16_t en = (int16_t)swap16(*(uint16_t*)val_ptr);
			if(ui.language == UI_LANGUAGE_ENGLISH)			GotoScreen(DGUSLCD_SCREEN_EN_UTILITIES);
			else											GotoScreen(DGUSLCD_SCREEN_CN_UTILITIES);
			if(save_par)	{ExtUI::injectCommands_P(PSTR("M500"));save_par=false;}
		}
		break;
		case Back_RK_returnleveling:
			if(ui.language == UI_LANGUAGE_ENGLISH)
			{
				GotoScreen(DGUSLCD_SCREEN_EN_LEVELING_Child);
//				if(ui.auto_level == 1)				GotoScreen(DGUSLCD_SCREEN_EN_LEVELING_Child);
				//else								GotoScreen(DGUSLCD_SCREEN_EN_LEVELING_Child_close);
			}
			else
			{
				GotoScreen(DGUSLCD_SCREEN_CN_LEVELING_Child);			
//				if(ui.auto_level == 1)				GotoScreen(DGUSLCD_SCREEN_CN_LEVELING_Child);
				//else								GotoScreen(DGUSLCD_SCREEN_CN_LEVELING_Child_close);
			}
		break;
		default:
		break;
	}
}
void DGUSScreenHandler::DisplayLevelingZ(const_float_t zval,int8_t index) {

	float f = zval;
	//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
	//do{ MYSERIAL1.print("index:"); MYSERIAL1.println(index); }while(0);
	//do{ MYSERIAL1.print("VP_Num_Point_1:"); MYSERIAL1.println(VP_Num_Point_1+(index*2)); }while(0);
	//do{ MYSERIAL1.print("f:"); MYSERIAL1.println(f); }while(0);
	//do{ MYSERIAL1.print("zval:"); MYSERIAL1.println(zval); }while(0);
    f *= cpow(10, 3);
	measure_index=index;
	//do{ MYSERIAL1.print("measure_index:"); MYSERIAL1.println(measure_index); }while(0);
	//do{ MYSERIAL1.print("measure_index1111:"); MYSERIAL1.println(((GRID_MAX_POINTS_X) * (GRID_MAX_POINTS_Y))); }while(0);
  	dgusdisplay.WriteVariable(VP_Num_Point_1+((index-1)*2),(int16_t)f );
	if(index<16)  	dgusdisplay.WriteVariable(VP_Num_Point_1+((index)*2),0 );
	if(index==15)	queue.enqueue_one_P(PSTR("M500"));
	if(current_screen==DGUSLCD_SCREEN_CN_MENSUR_LEVEL|| current_screen==DGUSLCD_SCREEN_EN_MENSUR_LEVEL){
		if(measure_index==((GRID_MAX_POINTS_X) * (GRID_MAX_POINTS_Y)))
		{
			//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
			if(ui.language == UI_LANGUAGE_CHINESE)
			{
				GotoScreen(DGUSLCD_SCREEN_CN_LEVELING_Child_OVER);
			}
			else
			{
				GotoScreen(DGUSLCD_SCREEN_EN_LEVELING_Child_OVER);
			}
		//	queue.enqueue_one_P(PSTR("M500"));
			measure_index=0;
		}
	}
}
void DGUSScreenHandler::DGUSLCD_UTILITIES_Leveling(DGUS_VP_Variable &var,void *val_ptr)
{
	switch(var.VP)
	{
		case VP_RK_Aux_Level:
		{
			int16_t index = (int16_t)swap16(*(uint16_t*)val_ptr);
			switch(index)
			{
				case 1:
			//	do{ MYSERIAL1.println(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
					queue.enqueue_one_P(PSTR("G0 Z5.0"));
					queue.enqueue_one_P(PSTR("G0 X155 G0 Y155"));
					queue.enqueue_one_P(PSTR("G0 Z0.0"));
					//ExtUI::injectCommands_P(PSTR("G0 Z5.0"));
					//ExtUI::injectCommands_P(PSTR("G0 X155 G0 Y155 Z0.0"));
				break;
				case 2:
			//	do{ MYSERIAL1.println(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
					queue.enqueue_one_P(PSTR("G0 Z5.0"));
					queue.enqueue_one_P(PSTR("G0 X72.5 G0 Y72.5"));
					queue.enqueue_one_P(PSTR("G0 Z0.0"));
					//ExtUI::injectCommands_P(PSTR("G0 Z5.0"));
					//ExtUI::injectCommands_P(PSTR("G0 X72.5 G0 Y72.5 Z0.0"));
				break;
				case 3:
				//do{ MYSERIAL1.println(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
					queue.enqueue_one_P(PSTR("G0 Z5.0"));
					queue.enqueue_one_P(PSTR("G0 X227.5 G0 Y72.5"));
					queue.enqueue_one_P(PSTR("G0 Z0.0"));
				//	ExtUI::injectCommands_P(PSTR("G0 Z5.0"));
				//	ExtUI::injectCommands_P(PSTR("G0 X227.5 G0 Y72.5 Z0.0"));
				break;
				case 4:
				//do{ MYSERIAL1.println(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
					queue.enqueue_one_P(PSTR("G0 Z5.0"));
					queue.enqueue_one_P(PSTR("G0 X227.5 G0 Y227.5"));
					queue.enqueue_one_P(PSTR("G0 Z0.0"));
				//	ExtUI::injectCommands_P(PSTR("G0 Z5.0"));
				//	ExtUI::injectCommands_P(PSTR("G0 X227.5 G0 Y227.5 Z0.0"));
				break;
				case 5:
				//do{ MYSERIAL1.println(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
					queue.enqueue_one_P(PSTR("G0 Z5.0"));
					queue.enqueue_one_P(PSTR("G0 X72.5 G0 Y227.5"));
					queue.enqueue_one_P(PSTR("G0 Z0.0"));
				//	ExtUI::injectCommands_P(PSTR("G0 Z5.0"));
				//	ExtUI::injectCommands_P(PSTR("G0 X72.5 G0 Y227.5 Z0.0"));
				break;
			}
		}
		case VP_RK_Leveling:
		{
			//if(!all_axes_homed() && (current_screen==DGUSLCD_SCREEN_CN_LEVELING||current_screen==DGUSLCD_SCREEN_EN_LEVELING))	{planner.synchronize();return;}
			motor_stper=10;
			measure_index=0;
			if(current_screen==DGUSLCD_SCREEN_CN_UTILITIES || current_screen==DGUSLCD_SCREEN_EN_UTILITIES)
			{
				ExtUI::injectCommands_P(PSTR("G28"));
				if(ui.language==UI_LANGUAGE_CHINESE)		GotoScreen(DGUSLCD_SCREEN_CN_LEVELING_Child);
				else if(ui.language==UI_LANGUAGE_ENGLISH)		GotoScreen(DGUSLCD_SCREEN_EN_LEVELING_Child);
		//		if(ui.language==UI_LANGUAGE_CHINESE)		GotoScreen(DGUSLCD_SCREEN_CN_LEVELING);
		//		else if(ui.language==UI_LANGUAGE_ENGLISH)		GotoScreen(DGUSLCD_SCREEN_EN_LEVELING);
		//		if(ui.language==UI_LANGUAGE_CHINESE)		GotoScreen(DGUSLCD_SCREEN_CN_LEVELING_Child);
		//		else if(ui.language==UI_LANGUAGE_ENGLISH)		GotoScreen(DGUSLCD_SCREEN_EN_LEVELING_Child);
				#if 1
				float (*p)[GRID_MAX_POINTS_Y]= (ExtUI::getMeshArray());
		//		uint8_t index=0;
				for(uint8_t index=0,i=0;i<GRID_MAX_POINTS_X;i++)
				{
					for(uint8_t j=0;j<GRID_MAX_POINTS_Y;j++)
					{
						//ExtUI::setMeshPoint(pos,index);
						dgusdisplay.WriteVariable(VP_Num_Point_1+((index)*2),(uint16_t)(  (*(*(p+i)+j)) * cpow(10, 3)) );
						//do{ MYSERIAL1.print("index"); MYSERIAL1.print(index); MYSERIAL1.print(":");MYSERIAL1.println((uint16_t)(  (*(*(p+i)+j)) * cpow(10, 3)) ); }while(0);
					//	do{ MYSERIAL1.print("float:"); MYSERIAL1.println(ExtUI::getMeshPoint(pos) ); }while(0);
						index++;
					}
				}
				#endif
			}
/*			else if(current_screen==DGUSLCD_SCREEN_CN_LEVELING||current_screen==DGUSLCD_SCREEN_EN_LEVELING)
			{
				if(ui.language==UI_LANGUAGE_CHINESE)		GotoScreen(DGUSLCD_SCREEN_CN_LEVELING_Child);
				else if(ui.language==UI_LANGUAGE_ENGLISH)		GotoScreen(DGUSLCD_SCREEN_EN_LEVELING_Child);
			}*/
		}
		break;
		case VP_RK_Measure_Level:
			if(measure_index==0){
				if(ui.language == UI_LANGUAGE_CHINESE)	GotoScreen(DGUSLCD_SCREEN_CN_MENSUR_LEVEL);
				else									GotoScreen(DGUSLCD_SCREEN_EN_MENSUR_LEVEL);
				ExtUI::injectCommands_P(PSTR("G29"));
			}
			else if(measure_index==((GRID_MAX_POINTS_X) * (GRID_MAX_POINTS_Y)))
			{
				if(ui.language == UI_LANGUAGE_CHINESE)	GotoScreen(DGUSLCD_SCREEN_CN_LEVELING_Child_OVER);
				else									GotoScreen(DGUSLCD_SCREEN_EN_LEVELING_Child_OVER);
			}
		break;
		default:
		break;
	}
}

void DGUSScreenHandler::DGUSLCD_SYS_config(DGUS_VP_Variable &var,void *val_ptr)
{
	switch(var.VP)
	{
		case VP_GetCFG:
		{
			uint8_t System_Config[4];
			memcpy(System_Config,(uint8_t*)val_ptr,sizeof(System_Config));
			memcpy(System_Config_0X80_D1,System_Config,sizeof(System_Config));
			//System_Config[0] |=0x5A;
			//System_Config[3] |=1<<2;
			//System_Config_0X80_D1=System_Config[3];
	//		IntoSleep();
  	  		//dgusdisplay.WriteVariable(VP_GetCFG, System_Config, sizeof(System_Config), true);
//			do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
//			do{ MYSERIAL1.print("System_Config[3]:"); MYSERIAL1.println(System_Config[3]); }while(0);
//			do{ MYSERIAL1.print("System_Config_0X80_D1:"); MYSERIAL1.println(System_Config_0X80_D1); }while(0);
		}
		break;
	}
}


void DGUSScreenHandler::DGUSLCD_UTILITIES_Deal(DGUS_VP_Variable &var,void *val_ptr)
{
	switch(var.VP)
	{

		case E_VP_UI_PK_PRINT:
		    top_file = 0;
			gcode_file_offset=0;
		    filelist.refresh();
			if(ui.language == UI_LANGUAGE_CHINESE)
			{
				if(has_sdcar)	GotoScreen(DGUSLCD_SCREEN_CN_SDFILELIST);
				else			GotoScreen(DGUSLCD_SCREEN_SDFILELIST_NULL_CN);
			}
			else
			{
				if(has_sdcar)	GotoScreen(DGUSLCD_SCREEN_EN_SDFILELIST);
				else			GotoScreen(DGUSLCD_SCREEN_SDFILELIST_NULL);
			}
		break;
		/*case C_VP_UI_PK_PRINT:
			GotoScreen(DGUSLCD_SCREEN_CN_UTILITIES);*/
		//break;
		case E_VP_UI_RK_UTILITIES:
		{
			motor_stper=10;//0.1*100;
			if(ui.language == UI_LANGUAGE_CHINESE)
			{
				GotoScreen(DGUSLCD_SCREEN_CN_UTILITIES);
			}
			else
			{
				GotoScreen(DGUSLCD_SCREEN_EN_UTILITIES);
			}
		}
		break;
		case E_VP_UI_RK_INFO:
		{
			if(ui.language == UI_LANGUAGE_CHINESE)
			{
				GotoScreen(DGUSLCD_SCREEN_CN_INFO);
			}
			else
			{
				GotoScreen(DGUSLCD_SCREEN_EN_INFO);
			}
//			do{ MYSERIAL1.print("VP_device_info:"); MYSERIAL1.println(VP_device_info); }while(0);
			DGUS_VP_Variable ramcopy;
			 char *tmpfi= "02000801_002";
  if (populate_VPVar(VP_device_info, &ramcopy)) {
//			do{ MYSERIAL1.print("tmpfi:"); MYSERIAL1.println(VP_device_info); }while(0);
    ramcopy.memadr = (void*)tmpfi;
    DGUSScreenHandler::DGUSLCD_SendStringToDisplay(ramcopy);
  }
		/*	 DGUS_VP_Variable tvar;
			 char tmpfilename[VP_SD_FileName_LEN + 1] = "";
			 tmpfi[12]=0x00;
			 tvar.size=32;
			 tvar.VP=VP_device_info;
			 tvar.memadr=(void*)tmpfilename;
			 memset(tmpfilename,'\0',sizeof(tmpfilename));
			 snprintf_P(tmpfilename, VP_SD_FileName_LEN, PSTR("%s"),tmpfi );
			 DGUSLCD_SendStringToDisplay(tvar);*/
			//char *tmp=;
			//dgusdisplay.WriteVariable(VP_device_info, tmp, 32, true);
		}	
		break;
		case VP_RK_Temp:
		{
			if(ui.language == UI_LANGUAGE_CHINESE)
			{
				GotoScreen(DGUSLCD_SCREEN_CN_TEMP);
			}
			else
			{
				GotoScreen(DGUSLCD_SCREEN_EN_TEMP);
			}
		}
		break;
		case VP_RK_Axis:
			GotoScreen(DGUSLCD_SCREEN_EN_AXIS_PAGE);
    		motor_stper=10;//david for reset 0.1
		break;
		case VP_RK_Filament:
			if(ui.language == UI_LANGUAGE_CHINESE)
			{
				GotoScreen(DGUSLCD_SCREEN_CN_FILAMENT_PAGE);
			}
			else
			{
				GotoScreen(DGUSLCD_SCREEN_EN_FILAMENT_PAGE);
			}
		break;
		case VP_RK_DryBox:
			
		//	do{ MYSERIAL1.print("thermalManager.degdrybox="); MYSERIAL1.println(thermalManager.degdrybox()); }while(0);
//		do{ MYSERIAL1.print("thermalManager.degdrybox():"); MYSERIAL1.println(thermalManager.degdrybox()); }while(0);
        	if(thermalManager.degdrybox()<-9)
        	{
				if(ui.language == UI_LANGUAGE_CHINESE)
				{
					GotoScreen(DGUSLCD_SCREEN_CN_TEST_DRYBOX);
				}
				else
				{
					GotoScreen(DGUSLCD_SCREEN_EN_TEST_DRYBOX);
				}        		
        	}
			else{
				if(ui.language == UI_LANGUAGE_CHINESE)
				{
					GotoScreen(DGUSLCD_SCREEN_CN_DRYBOX);
				}
				else
				{
					GotoScreen(DGUSLCD_SCREEN_EN_DRYBOX);
				}
			}
		break;
		case VP_RK_POWER_LOSS_RECOVERY:
		{
			int16_t en = (int16_t)swap16(*(uint16_t*)val_ptr);
			if(en==1)
			{
		      //queue.inject_P(PSTR("M1000"));
		      //dgusdisplay.WriteVariable(RTX_filename, filelist.filename(), 32, true);
		      power_loss_resume=1;		  
			  power_loss_state =1;
			  if(ui.language == UI_LANGUAGE_CHINESE)			GotoScreen(DGUSLCD_SCREEN_CN_WAITPOWERLOSS);
			  else												GotoScreen(DGUSLCD_SCREEN_CN_WAITPOWERLOSS);

	  		   recovery.resume();
			}
			else if(en == 2)
			{
     			recovery.cancel();
				if(ui.language == UI_LANGUAGE_CHINESE)				GotoScreen(DGUSLCD_SCREEN_CN_MAIN);
				else												GotoScreen(DGUSLCD_SCREEN_EN_MAIN);
				
		        power_loss_resume=0;
			}
		}
		break;
		case VP_RK_PowerLow:
		{
			int16_t en = (int16_t)swap16(*(uint16_t*)val_ptr);
			if(en==1)
			{
				ui.auto_turn_off=false;
			}	
			else
			{
				ui.auto_turn_off=true;;
			}
			save_par=true;
		}
		break;
		case VP_RK_disableaxis:
		{
			int16_t en = (int16_t)swap16(*(uint16_t*)val_ptr);
			if(en==1)
			{
				ExtUI::injectCommands_P(PSTR("M18"));
				//queue.enqueue_one_P(PSTR("M500"));
			}
		}
		break;
		case VP_RK_reset:
		{
			int16_t en = (int16_t)swap16(*(uint16_t*)val_ptr);
			if(en==1)
			{
				queue.enqueue_one_P(PSTR("M502"));
				queue.enqueue_one_P(PSTR("M500"));
				queue.enqueue_one_P(PSTR("M18"));
				queue.enqueue_one_P(PSTR("M1003"));
			}
		}
		break;
		case VP_RK_dec_filament_len:
			if(Filament_Len>0)
			Filament_Len--;
		break;
		case VP_RK_add_filament_len:
			if(Filament_Len<500)
			Filament_Len++;
		break;
		case VP_RK_language:
		{
			int16_t cn = (int16_t)swap16(*(uint16_t*)val_ptr);
			if(cn==1)//chinese
			{
				ui.language=UI_LANGUAGE_CHINESE;
				GotoScreen(DGUSLCD_SCREEN_CN_UTILITIES);
			    //char buf[5] = "M500";
			    //buf[5] = '\0';
			    //queue.enqueue_one_now(buf);
				ExtUI::injectCommands_P(PSTR("M500"));
			    ForceCompleteUpdate();				
			}
			else if(cn==2)//english
			{
				ui.language=UI_LANGUAGE_ENGLISH;
				GotoScreen(DGUSLCD_SCREEN_EN_UTILITIES);
			    //char buf[5] = "M500";
			    //buf[5] = '\0';
			    //queue.enqueue_one_now(buf);
				ExtUI::injectCommands_P(PSTR("M500"));
			    ForceCompleteUpdate();		
			}
			else //into language ui
			{
				if(ui.language==UI_LANGUAGE_CHINESE)				GotoScreen(DGUSLCD_SCREEN_LANGUAGE_SELECT);
				else												GotoScreen(DGUSLCD_SCREEN_LANGUAGE_SELECT_EN);
			}
		}
		break;
		case VP_RK_01_step:
			motor_stper=10;//0.1*100;
		break;
		case VP_RK_1_step:
			motor_stper=1*100;
		break;
		case VP_RK_10_step:
			motor_stper=10*100;
		break;
		case VP_RK_filament_pla:
//			filament_temp_u=PREHEAT_1_TEMP_HOTEND;
		filament_temp_u =thermalManager.degTargetHotend(0);

		break;
		case VP_RK_filament_abs:
			filament_temp_u =thermalManager.degTargetHotend(0);
//			filament_temp_u=PREHEAT_2_TEMP_HOTEND;
		break;
		case VP_RK_add_rate:
			if(feedrate_percentage<250)
			feedrate_percentage++;
		break;
		case VP_Add_Targe_Temp:
			if(drybox_targe_temp<DRYBOX_MAXTEMP)
			{
				drybox_targe_temp++;
        		thermalManager.setTargetHotend_DRYBOX(drybox_targe_temp);
			}
		break;
		case VP_Dec_Targe_Temp:
			if(drybox_targe_temp>=DRYBOX_MINTEMP)
			{
				drybox_targe_temp--;
        		thermalManager.setTargetHotend_DRYBOX(drybox_targe_temp);
			}
		break;
		case VP_Add_Dry_Time:
			drybox_timer+=30;
		break;
		case VP_Dec_Dry_Time:
			if(drybox_timer>0)	drybox_timer-=30;
		break;		
		case VP_DRYBOX_CANCEL:
        	thermalManager.setTargetHotend_DRYBOX(0);
        	thermalManager.degTargetHotend_drybox(TEMP_DRYBOX_CENTER_PIN);
			drybox_timer=6*60*60;
			drybox_timer_starttime=0;
			drybox_ing=false;
		break;
		case VP_DRYBOX_apply:
        	thermalManager.setTargetHotend_DRYBOX(drybox_targe_temp);
        	thermalManager.degTargetHotend_drybox(TEMP_DRYBOX_CENTER_PIN);
			drybox_timer_starttime=millis();
			drybox_ing=true;
		break;
		case VP_RK_dec_rate:
			if(feedrate_percentage>0)
			feedrate_percentage--;
		break;
		case VP_SD_FilePrint_AutoLeve:
		{
			int16_t enable = (int16_t)swap16(*(uint16_t*)val_ptr);
			if(enable==0)
			{
				ui.auto_level=1;
				//planner.leveling_active=true;
			}
			else if (enable==1)
			{
				ui.auto_level=0;
				//planner.leveling_active=false;
			}
			//ExtUI::injectCommands_P(PSTR("M500"));
			ForceCompleteUpdate();		
		}
		break;
		case VP_SD_FilePrint_FilamentRunout:
		{
			int16_t enable = (int16_t)swap16(*(uint16_t*)val_ptr);
			if(enable==0)
			{
				temp_runout_enable|= (0x01<<FilamentRunout_Bit);
			}
			else if (enable==1)
			{
				temp_runout_enable &= ~(0x01<<FilamentRunout_Bit);
			}
			if((temp_runout_enable&0x03) == 0)
			{
				detachInterrupt(0);
			}
			save_par=true;
			ForceCompleteUpdate();		
		}
		break;
		case VP_SD_FilePrint_Filament_Jams:
		{
			int16_t enable = (int16_t)swap16(*(uint16_t*)val_ptr);
			if(enable==0)
			{
				temp_runout_enable|= (0x01<<FilamentJams_Bit);
			}
			else if (enable==1)
			{
				temp_runout_enable &= ~(0x01<<FilamentJams_Bit);
			}
			if((temp_runout_enable&0x03) == 0)
			{
				detachInterrupt(0);
			}
			//ExtUI::injectCommands_P(PSTR("M500"));
			save_par=true;
			ForceCompleteUpdate();		
		}
		break;
		case VP_M108:
			ExtUI::injectCommands_P(PSTR("M108"));
			PopToOldScreen();
		break;
		//case VP_RK_apply:
		//	feedrate_percentage=targe_rate_set;
		//break;
		default:
		break;
	}	
}
void DGUSScreenHandler::onStartMove()
{
//	do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
	if(ExtUI::isPrintingFromMedia())	return;
//	do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
    if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_EN_WAIT_MOVE);
	else		  								  GotoScreen(DGUSLCD_SCREEN_CN_WAIT_MOVE);//homeing
	
}
void DGUSScreenHandler::onEndMove()
{
//	do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
	if(ExtUI::isPrintingFromMedia())	return;
//	do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
	PopToOldScreen();
}


void DGUSScreenHandler::onHomingStart()
{
	//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
	//if(ExtUI::isPrintingFromMedia())	return;
	//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
	//delay(1000);
    if(ui.language==UI_LANGUAGE_ENGLISH)		  GotoScreen(DGUSLCD_SCREEN_EN_LEVELING);
	else		  								  GotoScreen(DGUSLCD_SCREEN_CN_LEVELING);//homeing
	
}

void DGUSScreenHandler::onHomingComplete(bool t)
{
	planner.synchronize();
	if(t){
	//ExtUI::injectCommands_P(PSTR("G0 X155 Y155 Z0 F1200 "));
	//if(!ExtUI::isPrintingFromMedia()) queue.enqueue_one_P(PSTR("G0 X155 Y155 Z0 F300"));
	//else	ExtUI::injectCommands_P(PSTR("G0 X155 Y155 Z0 F1200 "));
	//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
	//do{ MYSERIAL1.print("planner.position.z:"); MYSERIAL1.println(planner.position.z); }while(0);
	}
	//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
	if(ExtUI::isPrintingFromMedia())
	{
		if(planner.leveling_active)
		{
			ExtUI::injectCommands("G29");
		}
	}
	//else{
	//do{ MYSERIAL1.print(__FILE__); MYSERIAL1.println(__LINE__); }while(0);
	PopToOldScreen();
	//}
}
void DGUSScreenHandler::resume_printUI()
{
//	do{ MYSERIAL1.print("resume_printUI:"); MYSERIAL1.println(GCodeQueue::is_online_print); }while(0);
//	do{ MYSERIAL1.print("resume_printUI_current_screen:"); MYSERIAL1.println(current_screen); }while(0);
//	LCD_SERIAL.print("resume_printUI:");	
//	LCD_SERIAL.println(GCodeQueue::is_online_print);
	static uint16_t CalCnt=0;
	if(CalCnt++>=10000)
	{
		CalCnt =0;
//		LCD_SERIAL.print("resume_printUI_current_screen:");	
//		LCD_SERIAL.println(current_screen);
	}

  if((GCodeQueue::is_online_print  || card.isPrinting() || card.isPaused())&& !card.isAbort())
  {
  	if(ui.language==UI_LANGUAGE_CHINESE)
  	{
  		if(current_screen!=DGUSLCD_SCREEN_CN_STATUS && current_screen!=DGUSLCD_SCREEN_CN_STATUS_PAUSE && current_screen!=DGUSLCD_SCREEN_CN_CHANGE_FILAMENT 
			&& current_screen!=DGUSLCD_SCREEN_CN_PRINTINGFINISHED && current_screen!=DGUSLCD_SCREEN_CN_LEVELING&& current_screen!=DGUSLCD_SCREEN_CN_PAUSE_SELECT
			&& current_screen!=DGUSLCD_SCREEN_CN_CANCEL_SELECT&& current_screen!=DGUSLCD_SCREEN_CN_PRINTINGCONTINUE&& current_screen!=DGUSLCD_SCREEN_CN_WAITHEATING
			&& current_screen!=DGUSLCD_SCREEN_CN_WAITOPERATE&&current_screen!=DGUSLCD_SCREEN_CN_WAITPOWERLOSS
			&&current_screen!=DGUSLCD_SCREEN_CN_ONLINEPRINT &&current_screen!=DGUSLCD_SCREEN_KILL
			&&current_screen!=DGUSLCD_SCREEN_CN_FILAMENT_CANCEL
		)
		{
		
//			if(GCodeQueue::is_online_print || card.isPrinting())		GotoScreen(DGUSLCD_SCREEN_CN_STATUS);
//			else													GotoScreen(DGUSLCD_SCREEN_CN_STATUS_PAUSE);
			if(card.isPrinting()){
				GotoScreen(DGUSLCD_SCREEN_CN_STATUS);
			}
			else if((GCodeQueue::is_online_print)){
				if(GCodeQueue::pause_online_print()==0)				
				GotoScreen(DGUSLCD_SCREEN_CN_ONLINEPRINT);
			
			}
			else{
				GotoScreen(DGUSLCD_SCREEN_CN_STATUS_PAUSE);
			}


			
  		}
  	}
	else
	{
  		if(current_screen!=DGUSLCD_SCREEN_EN_STATUS && current_screen!=DGUSLCD_SCREEN_EN_STATUS_PAUSE && current_screen!=DGUSLCD_SCREEN_EN_CHANGE_FILAMENT
			&& current_screen!=DGUSLCD_SCREEN_EN_PRINTINGFINISHED && current_screen!=DGUSLCD_SCREEN_EN_LEVELING && current_screen!=DGUSLCD_SCREEN_EN_PAUSE_SELECT
			&& current_screen!=DGUSLCD_SCREEN_EN_CANCEL_SELECT&& current_screen!=DGUSLCD_SCREEN_EN_PRINTINGCONTINUE&&current_screen!=DGUSLCD_SCREEN_CN_WAITPOWERLOSS)
		{
			if(GCodeQueue::is_online_print || card.isPrinting())		GotoScreen(DGUSLCD_SCREEN_EN_STATUS);
			else							GotoScreen(DGUSLCD_SCREEN_EN_STATUS_PAUSE);
  		}
	}
  }	
}
void DGUSScreenHandler::Periodic_task()
{
	if(save_par)
	{
		save_par=false;
		settings.save();
	}
}

bool DGUSScreenHandler::loop() {
  static millis_t cur_time=0,last_time=0;
  dgusdisplay.loop();//½ÓÊÕ´®¿ÚÐÅÏ¢

  const millis_t ms = millis();
  static millis_t next_event_ms = 0;
  static int millis_counter=0;

  if (!IsScreenComplete() || ELAPSED(ms, next_event_ms)){
    next_event_ms = ms + DGUS_UPDATE_INTERVAL_MS;
	resume_printUI();
	if(millis_counter++>120)
	{
		Periodic_task();
		millis_counter=0;
	}
    UpdateScreenVPData();
  }

  #if ENABLED(SHOW_BOOTSCREEN)
    static bool booted = false;

    if (!booted && TERN0(POWER_LOSS_RECOVERY, recovery.valid()))
      booted = true;

    if (!booted && ELAPSED(ms, TERN(USE_MKS_GREEN_UI, 1000, BOOTSCREEN_TIMEOUT)))
      booted = true;
  #endif
  return IsScreenComplete();
}

bool DGUSScreenHandler:: GetFilamentState_Check()
{
	if(ExtUI::getFilamentRunoutState()){
		do{ MYSERIAL1.println("getFilamentRunoutState"); }while(0);
		
//		LCD_SERIAL.println("GetFilamentState_Check111");

		if(ExtUI::getFilamentRunout_enabled()&0x03){
		  
		do{ MYSERIAL1.println("getFilamentRunout_enabled"); }while(0);
		
//		LCD_SERIAL.println("GetFilamentState_Check222");
		  return 1;
		}	
		
		return 1;
	}
	return 0;
}
#endif // DGUS_LCD_UI_SUNLU
